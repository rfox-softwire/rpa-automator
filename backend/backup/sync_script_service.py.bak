import os
import subprocess
import sys
import importlib.util
import importlib.metadata
import re
import json
import traceback
import ast
import logging
import time
from pathlib import Path
from typing import List, Dict, Optional, Tuple, Any, Set, Union
from dataclasses import dataclass
from enum import Enum, auto

from models.base import ScriptResult, ScriptError

logger = logging.getLogger(__name__)

class SecurityLevel(Enum):
    """Security levels for script execution."""
    STRICT = "strict"     # Maximum security, minimal permissions
    BALANCED = "balanced" # Reasonable security with common functionality
    PERMISSIVE = "permissive"  # Minimum security for maximum compatibility

@dataclass
class BrowserConfig:
    """Configuration for browser security settings."""
    disable_web_security: bool = False
    headless: bool = True
    sandbox: bool = True
    timeout_ms: int = 120000

class SyncScriptService:
    def __init__(
        self, 
        scripts_dir: str = "data/scripts",
        security_level: SecurityLevel = SecurityLevel.BALANCED,
        browser_config: Optional[BrowserConfig] = None
    ):
        """Initialize the SyncScriptService with security and browser configuration.
        
        Args:
            scripts_dir: Directory where scripts will be stored.
            security_level: Security level for script execution.
            browser_config: Custom browser configuration.
        """
        self.scripts_dir = Path(scripts_dir)
        self.security_level = security_level
        self.browser_config = browser_config or BrowserConfig()
        
        # Set up security defaults based on level
        if security_level == SecurityLevel.STRICT:
            self.browser_config.disable_web_security = False
            self.browser_config.sandbox = True
        elif security_level == SecurityLevel.BALANCED:
            self.browser_config.disable_web_security = False
            self.browser_config.sandbox = True
        else:  # PERMISSIVE
            self.browser_config.disable_web_security = True
            self.browser_config.sandbox = False
            
        try:
            self.scripts_dir.mkdir(parents=True, exist_ok=True)
        except Exception as e:
            logger.critical(
                "Failed to create scripts directory '%s': %s",
                scripts_dir, str(e),
                exc_info=True
            )
            raise RuntimeError(
                f"Failed to create scripts directory '{scripts_dir}': {str(e)}\n"
                "Please check permissions or specify a different directory."
            ) from e

    def _get_browser_args(self) -> List[str]:
        """Get browser launch arguments based on security level."""
        args = [
            '--disable-gpu',
            '--disable-dev-shm-usage',
            '--disable-software-rasterizer',
            f'--timeout={self.browser_config.timeout_ms}'
        ]
        
        # Add security-related arguments based on config
        if not self.browser_config.sandbox:
            args.append('--no-sandbox')
            args.append('--disable-setuid-sandbox')
        
        if self.browser_config.disable_web_security:
            args.extend([
                '--disable-web-security',
                '--disable-features=IsolateOrigins,site-per-process',
                '--disable-site-isolation-trials'
            ])
        
        return args

    def _ensure_playwright_browsers(self) -> bool:
        """Ensure Playwright browsers are installed and properly configured."""
        try:
            # Check if playwright is installed
            try:
                import playwright
            except ImportError:
                logger.info("Playwright package not found, it will be installed during dependency check")
                return True  # If playwright isn't installed, the package installation will handle it
                
            from playwright.sync_api import sync_playwright
            
            try:
                # Test browser launch with extended configuration
                with sync_playwright() as p:
                    browser = p.chromium.launch(
                        headless=True,
                        args=[
                            '--disable-gpu',
                            '--no-sandbox',
                            '--disable-dev-shm-usage',
                            '--disable-software-rasterizer',
                            '--disable-setuid-sandbox',
                            '--disable-web-security',
                            '--disable-features=IsolateOrigins,site-per-process',
                            '--disable-site-isolation-trials'
                        ],
                        timeout=120000  # 2 minutes timeout for browser launch
                    )
                    context = browser.new_context(
                        viewport={'width': 1920, 'height': 1080},
                        ignore_https_errors=True,
                        java_script_enabled=True,
                        bypass_csp=True
                    )
                    context.set_default_timeout(60000)  # 60 seconds timeout for operations
                    context.set_default_navigation_timeout(120000)  # 2 minutes for page loads
                    page = context.new_page()
                    
                    # Test a simple navigation
                    page.goto('about:blank', wait_until='domcontentloaded')
                    
                    # Clean up
                    page.close()
                    context.close()
                    browser.close()
                
                logger.info("Playwright browsers are properly configured")
                return True
                
            except Exception as e:
                logger.warning(f"Browser test failed, attempting to install/update browsers: {e}")
                try:
                    # Install browsers with more detailed logging
                    logger.info("Installing/updating Playwright browsers...")
                    result = subprocess.run(
                        [sys.executable, "-m", "playwright", "install", "--with-deps", "chromium"],
                        capture_output=True,
                        text=True,
                        timeout=300000  # 5 minutes timeout for installation
                    )
                    
                    if result.returncode == 0:
                        logger.info("Successfully installed/updated Playwright browsers")
                        logger.debug(f"Installation output: {result.stdout}")
                        return True
                    else:
                        logger.error(f"Failed to install browsers. Error: {result.stderr}")
                        return False
                        
                except subprocess.TimeoutExpired:
                    logger.error("Browser installation timed out after 5 minutes")
                    return False
                except Exception as install_error:
                    logger.error(f"Error during browser installation: {install_error}")
                    return False
                
        except Exception as e:
            logger.error(f"Critical error in _ensure_playwright_browsers: {e}", exc_info=True)
            return False

    def _is_safe_package_name(self, package_name: str) -> bool:
        """Validate that a package name is safe to install."""
        if not package_name or not isinstance(package_name, str):
            return False
        
        # Basic validation - only allow alphanumeric, dots, hyphens, underscores
        if not re.match(r'^[a-zA-Z0-9._-]+$', package_name):
            return False
        
        # Block common attack patterns
        blacklist = [';', '&&', '||', '`', '$', '(', ')', '{', '}', '[', ']', '|', '<', '>']
        return not any(char in package_name for char in blacklist)

    def install_package(self, package_name: str) -> bool:
        """Safely install a Python package with security checks.
        
        Args:
            package_name: Name of the package to install
            
        Returns:
            bool: True if installation was successful, False otherwise
        """
        if not self._is_safe_package_name(package_name):
            logger.error(f"Invalid package name: {package_name}")
            return False

        # Common package name variations
        package_mapping = {
            'cv2': 'opencv-python',
            'PIL': 'Pillow',
            'yaml': 'pyyaml',
            'bs4': 'beautifulsoup4',
            'sklearn': 'scikit-learn',
            'dateutil': 'python-dateutil'
        }
        
        actual_package = package_mapping.get(package_name, package_name)
        
        try:
            # Use subprocess with shell=False and proper argument lists
            cmd = [sys.executable, "-m", "pip", "install", "--user", actual_package]
            logger.info("Installing package: %s", actual_package)
            
            result = subprocess.run(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                check=True
            )
            
            logger.debug("Package installation output: %s", result.stdout)
            if result.stderr:
                logger.warning("Package installation warnings: %s", result.stderr)
                
            return True
            
        except subprocess.CalledProcessError as e:
            logger.error(
                "Failed to install package %s: %s",
                actual_package,
                e.stderr or str(e),
                exc_info=True
            )
            return False
        except Exception as e:
            logger.error(
                "Unexpected error installing package %s: %s",
                actual_package,
                str(e),
                exc_info=True
            )
            return False

    def get_imports_from_script(self, script_path: str) -> List[str]:
        """Extract all imported packages from a Python script.
        
        Args:
            script_path: Path to the Python script to analyze
            
        Returns:
            List of imported package names (top-level only)
        """
        imports: Set[str] = set()
        
        try:
            with open(script_path, 'r', encoding='utf-8') as f:
                try:
                    node = ast.parse(f.read())
                except SyntaxError as e:
                    print(f"Syntax error in script {script_path}: {e}")
                    return []
                except Exception as e:
                    print(f"Error parsing script {script_path}: {e}")
                    return []
            
            for item in ast.walk(node):
                try:
                    if isinstance(item, ast.Import):
                        for name in item.names:
                            # Skip relative imports and builtins
                            if not name.name.startswith('.'):
                                imports.add(name.name.split('.')[0])
                    elif isinstance(item, ast.ImportFrom):
                        # Skip relative imports
                        if item.module and not (item.level and item.level > 0):
                            imports.add(item.module.split('.')[0])
                except Exception as e:
                    print(f"Error processing import: {e}")
                    continue
                    
            # Filter out standard library modules and built-ins
            stdlib_pkgs = set(sys.builtin_module_names)
            imports = {pkg for pkg in imports 
                      if pkg and pkg not in stdlib_pkgs and not pkg.startswith('_')}
            
        except Exception as e:
            print(f"Unexpected error in get_imports_from_script: {e}")
            return []
            
        return list(imports)

    def ensure_packages_installed(self, script_path: str) -> bool:
        """Ensure all required packages are installed.
        
        Args:
            script_path: Path to the script to check dependencies for
            
        Returns:
            bool: True if all packages are installed successfully, False otherwise
        """
        try:
            # Get required imports from the script
            required_imports = self.get_imports_from_script(script_path)
            if not required_imports:
                print("No external package dependencies found.")
                return True
                
            print(f"Found required imports: {', '.join(required_imports)}")
            
            # Get installed packages (case-insensitive comparison)
            installed_packages = {}
            for dist in importlib.metadata.distributions():
                try:
                    installed_packages[dist.metadata['Name'].lower()] = dist.metadata['Name']
                except (KeyError, AttributeError):
                    continue
            
            # Check for missing packages
            missing = []
            for pkg in required_imports:
                pkg_lower = pkg.lower()
                if pkg_lower not in installed_packages:
                    # Try to find case-insensitive match
                    matching = [name for name in installed_packages if name.lower() == pkg_lower]
                    if not matching:
                        missing.append(pkg)
            
            if not missing:
                print("All required packages are already installed.")
                return True
                
            print(f"Installing missing packages: {', '.join(missing)}")
            
            # Try to install all missing packages at once first (faster)
            if len(missing) > 1:
                try:
                    subprocess.check_call(
                        [sys.executable, "-m", "pip", "install"] + missing,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE
                    )
                    print("Successfully installed all packages.")
                    return True
                except subprocess.CalledProcessError:
                    print("Batch installation failed, trying packages one by one...")
            
            # If batch install failed, try installing one by one
            success = True
            for pkg in missing:
                if not self.install_package(pkg):
                    print(f"Failed to install package: {pkg}")
                    success = False
                    
            return success
            
        except Exception as e:
            print(f"Error ensuring packages are installed: {e}")
            traceback.print_exc()
            return False

    def _get_page_history_from_tracker(self) -> List[Dict[str, Any]]:
        """
        Extract page history from the Playwright tracker for repair context.
        
        Returns:
            List of page history entries with context for repair prompts
        """
        try:
            from backend.services.playwright_tracker import PlaywrightTracker
            
            if hasattr(PlaywrightTracker, '_instance'):
                tracker = PlaywrightTracker._instance
                if tracker and hasattr(tracker, 'get_page_history'):
                    history = tracker.get_page_history()
                    logger.debug("Retrieved %d page history entries", len(history))
                    
                    # Format history for repair context
                    formatted_history = []
                    for entry in history:
                        formatted_entry = {
                            'url': entry.get('url', ''),
                            'title': entry.get('title', ''),
                            'timestamp': entry.get('timestamp', ''),
                            'action': entry.get('action', ''),
                            'status': entry.get('status', '')
                        }
                        # Add additional context if available
                        if 'screenshot' in entry:
                            formatted_entry['has_screenshot'] = True
                        if 'console_logs' in entry:
                            formatted_entry['console_logs_count'] = len(entry['console_logs'])
                            
                        formatted_history.append(formatted_entry)
                    
                    return formatted_history
                    
        except Exception as e:
            logger.warning("Could not retrieve page history: %s", str(e), exc_info=True)
        
        return []

    def run_script(self, script_path: str) -> ScriptResult:
        """
        Execute a Python script with proper error handling and page history.
        
        Args:
            script_path: Path to the Python script to execute
            
        Returns:
            ScriptResult: Result of the script execution with page history
        """
        script_content = ""
        start_time = time.time()
        page_history = []
        
        try:
            # Ensure the script exists and is accessible
            if not os.path.exists(script_path):
                error_msg = f"Script not found: {script_path}"
                logger.error(error_msg)
                return ScriptResult(
                    success=False,
                    error_type="FileNotFoundError",
                    error_details={"script_path": script_path, "message": "Script file not found"},
                    page_history=page_history,
                    script_content=script_content
                )
            
            # Read the script content
            with open(script_path, 'r', encoding='utf-8') as f:
                script_content = f.read()
            
            # Check if this is a Playwright script and ensure browsers are installed
            is_playwright_script = 'playwright' in script_content.lower()
            if is_playwright_script:
                logger.info("Detected Playwright script, ensuring browsers are installed...")
                if not self._ensure_playwright_browsers():
                    error_msg = "Failed to install/configure required Playwright browsers"
                    logger.error(error_msg)
                return ScriptResult(
                    success=False,
                    error_type="BrowserInstallationError",
                        error_details={"message": error_msg}
                )
            
            # Get page history before execution for context
            page_history = self._get_page_history_from_tracker()
            
            # Ensure required packages are installed
            logger.info("Ensuring required packages are installed...")
            if not self.ensure_packages_installed(script_path):
                error_msg = "Failed to install required packages"
                logger.error(error_msg)
                return ScriptResult(
                    success=False,
                    error_type="DependencyError",
                    error_details={"message": error_msg},
                    script_content=script_content,
                    page_history=page_history
                )
            
            # Prepare environment variables
            env = os.environ.copy()
            env.update({
                'PYTHONUNBUFFERED': '1',  # Ensure output is unbuffered
                'PYTHONIOENCODING': 'utf-8',  # Ensure UTF-8 encoding
                'PLAYWRIGHT_BROWSERS_PATH': '0',  # Use default browser location
            })
            
            # Execute the script with real-time output handling
            logger.info("Starting script execution: %s", script_path)
            
            # Create a buffer to capture output
            stdout_buffer = []
            stderr_buffer = []
            
            try:
                process = subprocess.Popen(
                    [sys.executable, script_path],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    bufsize=1,  # Line buffered
                    universal_newlines=True,
                    env=env,
                    cwd=os.path.dirname(script_path)
                )
            
                # Log the start of execution with security context
                logger.info(
                    "Script execution started (PID: %d, Security: %s, Sandbox: %s)",
                    process.pid,
                    self.security_level.value,
                    self.browser_config.sandbox
                )
            
            def read_stream(stream, buffer, is_stderr=False):
                """Read from the given stream and buffer the output."""
                try:
                    for line in iter(stream.readline, ''):
                        line = line.rstrip('\n')
                        if line:  # Only process non-empty lines
                            buffer.append(line)
                            # Log important output in real-time
                            if is_stderr:
                                logger.error(f"[Script Error] {line}")
                            elif line.startswith(('INFO:', 'WARNING:', 'ERROR:')):
                                logger.info(f"[Script Output] {line}")
                            elif len(line) < 500:  # Don't log very long lines
                                logger.debug(f"[Script Output] {line}")
                except Exception as e:
                    logger.warning(f"Error reading from {'stderr' if is_stderr else 'stdout'}: {e}")
            
            # Start threads to read stdout and stderr
            from threading import Thread
            stdout_thread = Thread(
                target=read_stream,
                args=(process.stdout, stdout_buffer),
                daemon=True
            )
            stderr_thread = Thread(
                target=read_stream,
                args=(process.stderr, stderr_buffer, True),
                daemon=True
            )
            
            stdout_thread.start()
            stderr_thread.start()
            
            try:
                # Wait for the process to complete with a timeout
                process.wait(timeout=300)  # 5 minutes timeout
                returncode = process.returncode
                
                # Wait for output threads to finish with a reasonable timeout
                output_timeout = 5.0
                stdout_thread.join(timeout=output_timeout)
                if stdout_thread.is_alive():
                    logger.warning("Timed out waiting for stdout thread to complete")
                
                stderr_thread.join(timeout=output_timeout)
                if stderr_thread.is_alive():
                    logger.warning("Timed out waiting for stderr thread to complete")
                
                # Join the output lines
                stdout = '\n'.join(stdout_buffer)
                stderr = '\n'.join(stderr_buffer)
                
                # Log completion status
                execution_time = time.time() - start_time
                logger.info(
                    f"Script execution completed in {execution_time:.2f} seconds "
                    f"with return code {returncode}"
                )
                
                # Get page history if this was a Playwright script
                page_history = []
                if is_playwright_script:
                    try:
                        page_history = self._get_page_history_from_tracker()
                        logger.info(f"Captured {len(page_history)} page history entries")
                    except Exception as e:
                        logger.error(f"Error capturing page history: {e}", exc_info=True)
                
                # Check the return code
                if returncode == 0:
                    result = ScriptResult(
                        success=True,
                        stdout=stdout,
                        stderr=stderr,
                        returncode=returncode,
                        script_content=script_content,
                        script_path=script_path,
                        page_history=page_history,
                        execution_time=execution_time
                    )
                    logger.info("Script executed successfully")
                    return result
                else:
                    # Try to extract error information
                    error_type = "ScriptError"
                    error_message = stderr_buffer[-1] if stderr_buffer else "Unknown error"
                    
                    # Log detailed error information
                    if stderr_buffer:
                        logger.error("Script execution failed with errors:")
                        for line in stderr_buffer[-10:]:  # Only show last 10 lines to avoid log spam
                            logger.error(f"  {line}")
                    
                    # Wait for the process to complete
                try:
                    process.wait(timeout=300)  # 5 minute timeout
                    
                    # Get any remaining output
                    stdout, stderr = process.communicate()
                    if stdout:
                        stdout_buffer.append(stdout)
                    if stderr:
                        stderr_buffer.append(stderr)
                        
                    # Check return code
                    if process.returncode != 0:
                        error_msg = f"Script failed with return code {process.returncode}"
                        if stderr_buffer:
                            error_msg += f": {''.join(stderr_buffer)[-500:]}"  # Last 500 chars of stderr
                        logger.error(error_msg)
                        return ScriptResult(
                            success=False,
                            error_type="ScriptExecutionError",
                            error_details={"returncode": process.returncode, "message": error_msg},
                            script_content=script_content,
                            page_history=page_history
                        )
                    
                    # Success case
                    return ScriptResult(
                        success=True,
                        output=''.join(stdout_buffer),
                        execution_time=time.time() - start_time,
                        script_content=script_content,
                        page_history=page_history
                    )
                    
                except subprocess.TimeoutExpired:
                    logger.error("Script execution timed out after 5 minutes")
                    process.kill()
                    return ScriptResult(
                        success=False,
                        error_type="TimeoutError",
                        error_details={"message": "Script execution timed out after 5 minutes"},
                        script_content=script_content,
                        page_history=page_history
                    )
                    
            except Exception as e:
                logger.error("Error during script execution: %s", str(e), exc_info=True)
                return ScriptResult(
                    success=False,
                    error_type=type(e).__name__,
                    error_details={"message": str(e)},
                    error_type="TimeoutError",
                    error_details={
                        "message": "Script execution timed out after 5 minutes",
                        "execution_time": time.time() - start_time
                    },
                    script_content=script_content,
                    script_path=script_path,
                    execution_time=time.time() - start_time
                )
                
        except Exception as e:
            error_msg = f"Unexpected error during script execution: {str(e)}"
            logger.error(error_msg, exc_info=True)
            return ScriptResult(
                success=False,
                error_type="ExecutionError",
                error_details={
                    "message": error_msg,
                    "exception": str(e),
                    "execution_time": time.time() - start_time if 'start_time' in locals() else None
                },
                script_content=script_content,
                script_path=script_path,
                execution_time=time.time() - start_time if 'start_time' in locals() else None
            )
    
    def save_script(self, content: str, script_id: str = None) -> tuple[str, str]:
        """Save a script to a file and return its path and ID."""
        if script_id is None:
            import uuid
            script_id = str(uuid.uuid4())
            
        script_filename = f"script_{script_id}.py"
        script_path = self.scripts_dir / script_filename
        
        with open(script_path, 'w', encoding='utf-8') as f:
            f.write(content)
            
        return str(script_path), script_id
